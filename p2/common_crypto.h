#pragma once

#include <openssl/pem.h>
#include <openssl/rand.h>
#include <string>

#include "common_buf.h"

/** size of RSA key */
const int RSA_KEYSIZE = 2048;

/** size of AES key */
const int AES_KEYSIZE = 32;

/** size of blocks that get encrypted... also size of IV */
const int AES_BLOCKSIZE = 16;

/** chunk size for reading/writing from files */
const int AES_BUFSIZE = 1024;

/**
 * Load an RSA public key from the given filename
 *
 * @param filename The name of the file that has the public key in it
 *
 * @returns An RSA context for encrypting with the provided public key, or
 *          nullptr on error
 */
RSA *load_pub(const char *filename);

/**
 * Load an RSA private key from the given filename
 *
 * @param filename The name of the file that has the private key in it
 *
 * @returns An RSA context for encrypting with the provided private key, or
 *          nullptr on error
 */
RSA *load_pri(const char *filename);

/**
 * Produce an RSA key and save its public and private parts to files
 *
 * @param pub The name of the public key file to generate
 * @param pri The name of the private key file to generate
 *
 * @returns true on success, false on any error
 */
bool generate_rsa_key_files(std::string pub, std::string pri);

/**
 * Run the AES symmetric encryption/decryption algorithm on a buffer of bytes.
 * Note that this will do either encryption or decryption, depending on how the
 * provided CTX has been configured.  After calling, the CTX cannot be used
 * until it is reset.
 *
 * @param ctx The pre-configured AES context to use for this operatoin
 * @param msg A buffer of bytes to encrypt/decrypt
 *
 * @returns A buf_t with the encrypted or decrypted result, or -1 on error
 */
buf_t aes_crypt_msg(EVP_CIPHER_CTX *ctx, buf_t msg);

/**
 * Create an AES key.  A key is two parts, the key itself, and the
 * initialization vector.  Each is just random bits.  Our key will just be a
 * stream of random bits, long enough to be split into the actual key and the
 * iv.
 *
 * @returns a buf_t holding the key and iv bits
 */
buf_t create_aes_key();

/**
 * Create an aes context for doing a single encryption or decryption.  The
 * context must be reset after each full encrypt/decrypt.
 *
 * @param key     The bits of the key and iv, in a single array
 * @param encrypt True to encrypt, false to decrypt
 *
 * @returns An AES context for doing encryption.  Note that the context can be
 *          reset in order to re-use this object for another encryption.
 */
EVP_CIPHER_CTX *create_aes_context(unsigned char *key, bool encrypt);

/**
 * Reset an existing AES context, so that we can use it for another
 * encryption/decryption
 *
 * @param ctx     The AES context to reset
 * @param key     A stream of random bits to use as the key and iv.  Should be
 *                generated by create_aes_key().
 * @param encrypt True to create an encryption context, false to create a
 *                decryption context
 *
 * @returns false on error, true if the context is reset and ready to use again
 */
bool reset_aes_context(EVP_CIPHER_CTX *ctx, unsigned char *key, bool encrypt);

/**
 * When an AES context is done being used, call this to reclaim its memory
 *
 * @param ctx The context to reclaim
 */
void reclaim_aes_context(EVP_CIPHER_CTX *ctx);

/**
 * Use a server's public RSA key to encrypt the bits of the client's AES key
 *
 * @param pubkey The server's public key
 * @param key_iv The client's AES key and initialization vector, as a single
 *               byte stream
 *
 * @returns The encrypted AES key, or -1 on error
 */
buf_t make_encrypted_key(RSA *pubkey, unsigned char *key_iv);

/**
 * If the given basename resolves to basename.pri and basename.pub, then load
 * basename.pri and return it.  If one or the other doesn't exist, then there's
 * an error.  If both don't exist, create them and then load basename.pri.
 *
 * @param basename The basename of the .pri and .pub files for RSA
 *
 * @returns The RSA context from loading the private file, or nullptr on error
 */
RSA *init_RSA(std::string basename);